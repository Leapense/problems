#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Sieve of Eratosthenes로 max_limit까지 소수를 구하는 함수
vector<int> getPrimes(int max_limit) {
    vector<bool> isComposite(max_limit + 1, false);
    vector<int> primes;
    for (int i = 2; i <= max_limit; ++i) {
        if (!isComposite[i]) {
            primes.push_back(i);
            for (long long j = (long long)i * i; j <= max_limit; j += i)
                isComposite[j] = true;
        }
    }
    return primes;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    // N의 최댓값은 100,000. P의 최대가 100일 때, 필요한 소수 범위를 고려하여 충분히 큰 상한을 잡는다.
    // N=100,000인 경우, 첫 100개의 소수는 약 110,000 정도까지 있으므로 110,000 이상으로 잡으면 안전하다.
    const int SIEVE_LIMIT = 110000;
    vector<int> globalPrimes = getPrimes(SIEVE_LIMIT);

    while (true) {
        int N, P;
        cin >> N >> P;
        if(N == -1 && P == -1)
            break;
        
        // N보다 큰 소수를 전역 소수 리스트에서 이진 탐색으로 찾는다.
        auto it = upper_bound(globalPrimes.begin(), globalPrimes.end(), N);
        // P번째 합을 구하기 위해 필요한 후보 소수 개수는 P개 (두 배열의 k번째 합은 보통 첫 k개 안에 있다)
        int countNeeded = P;
        vector<int> candidates;
        for (int i = 0; i < countNeeded; i++) {
            // 안전하게 globalPrimes의 끝을 넘지 않는지 확인
            if(it + i < globalPrimes.end())
                candidates.push_back(*(it + i));
        }
        
        // 두 후보 소수의 모든 쌍의 합 (중복 허용)을 구한다.
        vector<int> sums;
        sums.reserve(candidates.size() * candidates.size());
        for (int i = 0; i < candidates.size(); i++){
            for (int j = 0; j < candidates.size(); j++){
                sums.push_back(candidates[i] + candidates[j]);
            }
        }
        // 오름차순 정렬 (동일 합은 중복으로 계산됨)
        sort(sums.begin(), sums.end());
        // P번째 (1-indexed) 원소 출력
        cout << sums[P - 1] << "\n";
    }
    return 0;
}

